#!/usr/bin/env python

#                  High-Level Reduction Functions
#           A part of the SNS Analysis Software Suite.
#
#                  Spallation Neutron Source
#          Oak Ridge National Laboratory, Oak Ridge TN.
#
#
#                             NOTICE
#
# For this software and its associated documentation, permission is granted
# to reproduce, prepare derivative works, and distribute copies to the public
# for any purpose and without fee.
#
# This material was prepared as an account of work sponsored by an agency of
# the United States Government.  Neither the United States Government nor the
# United States Department of Energy, nor any of their employees, makes any
# warranty, express or implied, or assumes any legal liability or
# responsibility for the accuracy, completeness, or usefulness of any
# information, apparatus, product, or process disclosed, or represents that
# its use would not infringe privately owned rights.
#

# $Id$

"""
This program covers the functionality outlined in 2.2.1 Powder or
amorphous material reduction in <CHANGE:DR_Lib_RS.doc>.
"""

def dead_time_correction(data_som):
    """Step 1. Apply dead time correction to each I(TOF) using
    function 3.38. The result is ItiXY(TOF)."""

    return data_som


def subtract_norm_bkg_from_norm(norm_som, norm_bkg_som):
    """Step 2. Subtract measured normalization background using 3.6
    with ItNXY(TOF) as data1 and ItNBXY(TOF) as data2. The result is
    ItbNXY(TOF)."""

    if norm_som is None:
        return None
    elif norm_bkg_som is None:
        return norm_som

    return common_lib.sub_ncerr(norm_som, norm_bkg_som)


def subtract_dark_count_from_data(data_som, dc_som):
    """Step 3. Subtract the dark count spectrum using function 3.6
    with ItDXY(TOF) as data1 and ItDCXY(TOF) as data2. The result of
    this is ItdDXY(TOF)."""

    if dc_som is None:
        return data_som

    return common_lib.sub_ncerr(data_som, dc_som)


def determine_time_indep_bkg(conf, data_som):
    """Step 4. Determine the sample dependent, time independent
    background B by fitting a line to predetermined end points of
    ItdDXY(TOF) using function 3.43."""

    kwargs = {}

    if conf.TOF_start is not None:
        kwargs["start"] = conf.TOF_start

    if conf.TOF_end is not None:
        kwargs["end"] = conf.TOF_end

    return common_lib.weighted_average(data_som, **kwargs)


def subtract_time_indep_bkg(data_som, B):
    """Step 5. Subtract B from the data spectrum using function 3.2
    with ItdDXY(TOF) as data1 and B as a. The result is ItdsDXY(TOF)."""

    if B is None:
        return data_som

    return dr_lib.subtract_time_indep_bkg(data_som, B)


def subtract_bkg_from_data(config, data_som, bkg_som):
    """Step 6. Subtract the measured background spectrum from the data
    spectrum using function 3.6 with ItdsDXY(TOF) as data1 and
    ItBXY(TOF) as data2. The result of this is ItdsbDXY(TOF)."""

    if bkg_som is None:
        return data_som

    return common_lib.sub_ncerr(data_som, bkg_som)


def norm_data_by_van(data_som, norm_som):
    """Step 7. Normalize ItdsbDXY(TOF) by vanadium spectrum,
    ItbNXY(TOF), using function 3.9. The result is ItdsbnDXY(TOF)."""

    if norm_som is None:
        return data_som

    return common_lib.div_ncerr(data_som, norm_som)


def convert_data_and_mon_to_wavelength(conf, data_som, mon2_som):
    """Step 8. Convert ItM2(TOF) and ItdsbnDXY(TOF) to ItM2(lambda)
    and ItdsbnDXY(lambda) using function 3.15 for M2 and function 3.48
    for DXY."""

    if mon2_som is not None:
        mon2_som1 = common_lib.tof_to_wavelength(mon2_som, units="microsecond")
    else:
        mon2_som1 = None

    data_som1 = common_lib.tof_to_initial_wavelength_igs_lin_time_zero(
        data_som,
        units="microsecond",
        run_filter= not conf.no_filter)
        
    return (data_som1, mon2_som1)


def rebin_mon_eff(mon2_som, mon2_eff):
    """Step 9. Rebin the monitor efficiency to each monitor's
    wavelength axis using 3.12. The input is the efficiency
    eM2(lambda) with the output being erM2(lambda)."""

    return dr_lib.rebin_efficiency(mon2_som, mon2_eff)


def eff_correct_mon(mon2_som, mon2_eff):
    """Step 10. Divide ItM2(lambda) by erM2(lambda) using function
    3.9. The result is IeM2(lambda)."""

    if mon2_eff is None:
        return mon2_som

    return common_lib.div_ncerr(mon2_som, mon2_eff)


def rebin_det_eff(data_som, det_eff):
    """Step 11. Rebin eDXY(lambda) to the same binning in wavelength
    as ItbdnDXY(lambda) by using function 3.12. The result is
    erDXY(lambda)"""

    return dr_lib.rebin_efficiency(data_som, det_eff)


def eff_correct_data(data_som, det_eff):
    """Step 12. Correct ItbdneDXY(lambda) for detector efficiency by
    using the function in 3.9 using ItbdnDXY(lambda) as data1 and
    erDXY(lambda) as data2. The result is ItbdneDXY(lambda)."""

    if det_eff is None:
        return data_som

    return common_lib.div_ncerr(data_som, det_eff)


def norm_data_by_mon(config, data_som, mon_som):
    """Step 13. Normalize by the integrated monitor intensity using
    3.5 using ItbdneDXY(lambda) as data1 and IteM2(lambda) as a. The
    result of this is S(lambda)."""

    if mon_som is None:
        return data_som

    kwargs = {}

    if config.mon_start is not None:
        kwargs["start"] = config.mon_start

    if config.mon_end is not None:
        kwargs["end"] = config.mon_end

    int_mon_int = dr_lib.integrate_axis(mon_som, **kwargs)

    return common_lib.div_ncerr(data_som, int_mon_int)

def calc_k_initial(config, data_som):
    """Step 14. Calculate incident wavevector using function 3.24."""

    return common_lib.wavelength_to_scalar_k(data_som)

def calc_E_initial(config, data_som):
    """Step 15. Calculate incident energy using function 3.22."""

    return common_lib.wavelength_to_energy(data_som,
                                           offset=config.\
                                           initial_energy_offset)

def calc_energy_transfer(conf, data_som):
    """Combines Steps 17 and 18 to calculate energy transfer using function
    3.30."""

    return dr_lib.igs_energy_transfer(data_som,
                                      lambda_f=conf.wavelength_final,
                                      offset=conf.final_energy_offset)

def create_final(conf, E_t_som, k_i_som):
    """Combines Steps 16,19,20 and 21 to create final 2D spectrum"""

    if conf.correct:
        return dr_lib.create_E_vs_Q_igs(E_t_som, k_i_som,
                                        conf.E_bins, conf.Q_bins,
                                        so_id="Full Detector",
                                        y_label="counts",
                                        y_units="counts / (ueV * A^-1)",
                                        x_labels=["Q transfer",
                                                  "energy transfer"],
                                        x_units=["1/Angstroms","ueV"])
    else:
        return dr_lib.create_2D_dist(data_som, conf.E_bins, conf.Q_bins,
                                     so_id="Full Detector",
                                     y_label="counts",
                                     y_units="counts / (ueV * A^-1)",
                                     x_labels=["Q transfer","energy transfer"],
                                     x_units=["1/Angstroms","ueV"])

def run(config, tim=None):
    import sys
    
    if config.data is None:
        raise RuntimeError("Need to pass a data filename to the driver "\
                           +"script.")

    import DST
        
    try:
        data_dst = DST.getInstance("application/x-NeXus", config.data)
    except SystemError:
        print "ERROR: Failed to data read file %s" % config.data
        sys.exit(-1)

    if tim is not None:
        tim.getTime(False)
        old_time = tim.getOldTime()

    if not config.mc:
        so_axis = "time_of_flight"
    else:
        so_axis = "Time_of_Flight__us_"

    if config.verbose:
        print "Reading data file"

    d_som1 = data_dst.getSOM(config.data_paths, so_axis,
                             roi_file=config.roi_file)

    if tim is not None:
        tim.getTime(msg="After reading data: ")

    if config.no_mon_norm:
        m_som1 = None
    else:
        if config.verbose:
            print "Reading in monitor data from data file"
        som_id = config.mon_path
        m_som1 = data_dst.getSOM(som_id, so_axis)
        if tim is not None:
            tim.getTime(msg="After reading monitor data: ")

    data_dst.release_resource()

    if config.mc:
        d_som1.attr_list["Wavelength_final"] = (6.627, 0.0)

    if config.dead_time is not None:
        if config.verbose:
            print "Doing dead-time correction"
            
        d_som2 = dead_time_correction(d_som1)
        if tim is not None:
            tim.getTime(msg="After dead-time correction: ")
    else:
        d_som2 = d_som1

    del d_som1

    if config.norm is not None:
        if config.verbose:
            print "Reading normalization file"
            
        norm_dst = DST.getInstance("application/x-NeXus", config.norm)
        n_som1 = norm_dst.getSOM(config.data_paths, so_axis,
                                 roi_file=config.roi_file)
        if tim is not None:
            tim.getTime(msg="After reading normalization data: ")

        norm_dst.release_resource()
    else:
        n_som1 = None

    if config.norm_bkg is not None:
        if config.verbose:
            print "Reading normalization background file"
            
        norm_bkg_dst = DST.getInstance("application/x-NeXus", config.norm_bkg)
        n_bkg_som1 = norm_bkg_dst.getSOM(config.data_paths, so_axis,
                                         roi_file=config.roi_file)
        if tim is not None:
            tim.getTime(msg="After reading normalization background data: ")

        n_bkg_som1.release_resource()
    else:
        n_bkg_som1 = None

    if config.verbose and n_bkg_som1 is not None:
        print "Subtracting background for normalization"
        
    n_som2 = subtract_norm_bkg_from_norm(n_som1, n_bkg_som1)

    if n_bkg_som1 is not None:
        if tim is not None:
            tim.getTime(msg="After subtraction background from "\
                        +"normalization: ")

    del n_bkg_som1, n_som1

    if config.dark_count is not None:
        if config.verbose:
            print "Reading dark count file"
            
        dc_dst = DST.getInstance("application/x-NeXus", config.dark_count)
        dc_som1 = dc_dst.getSOM(config.data_paths, so_axis,
                                roi_file=config.roi_file)
        if tim is not None:
            tim.getTime(msg="After reading dark-count data: ")

        dc_dst.release_resource()
    else:
        dc_som1 = None

    if config.verbose and dc_som1 is not None:
        print "Subtracting dark count from data"
        
    d_som3 = subtract_dark_count_from_data(d_som2, dc_som1)

    if dc_som1 is not None:
        if tim is not None:
            tim.getTime(msg="After subtracting dark counts from data: ")

    del d_som2, dc_som1

    if not config.no_tib:
        if config.verbose:
            print "Determining time-independent background from data"
            
        B = determine_time_indep_bkg(config, d_som3)
        if tim is not None:
            tim.getTime(msg="After determining time-independent background: ")
    else:
        B = None

    if config.verbose and B is not None:
        print "Subtracting time-independent background from data"
        
    d_som4 = subtract_time_indep_bkg(d_som3, B)

    if B is not None:
        if tim is not None:
            tim.getTime(msg="After subtracting time-independent background: ")

    del d_som3, B

    if config.data_bkg is not None:
        if config.verbose:
            print "Reading in background data file"
            
        bkg_dst = DST.getInstance("application/x-NeXus", config.data_bkg)
        bkg_som1 = bkg_dst.getSOM(config.data_paths, so_axis,
                                  roi_file=config.roi_file)
        if tim is not None:
            tim.getTime(msg="After reading sample background data: ")

        bkg_dst.release_resource()
    else:
        bkg_som1 = None

    if config.verbose and bkg_som1 is not None:
        print "Subtracting background from data"
        
    d_som5 = subtract_bkg_from_data(config, d_som4, bkg_som1)

    if bkg_som1 is not None:
        if tim is not None:
            tim.getTime(msg="After subtraction background from data: ")

    del d_som4, bkg_som1

    if config.verbose and n_som2 is not None:
        print "Normalizing data by normalization data"

    d_som6 = norm_data_by_van(d_som5, n_som2)

    if n_som2 is not None:
        if tim is not None:
            tim.getTime(msg="After normalizing data: ")

    del d_som5, n_som2

    if config.mon_geom is not None:
        if config.verbose:
            print "Reading monitor geometry file"
            
        mon_geom_dst = DST.getInstance("application/x-NxsGeom",
                                       config.mon_geom)
        mon_geom_dst.setGeometry(config.mon_path, m_som1)
        mon_geom_dst.release_resource()

    if config.det_geom is not None:
        if config.verbose:
            print "Reading in detector geometry file"
            
        det_geom_dst = DST.getInstance("application/x-NxsGeom",
                                       config.det_geom)
        det_geom_dst.setGeometry(config.data_paths, d_som6)
        det_geom_dst.release_resource()

    # Note: wavelength_final MUST be a tuple
    if config.wavelength_final is None:
        try:
            config.wavelength_final = d_som6.attr_list["Wavelength_final"]
            if config.wavelength_final is None:
                raise RuntimeError("A final wavelength was not provided on "\
                                   +"the command-line nor in the data file. "\
                                   +"Please provide one.")
            else:
                pass
        except KeyError:
            raise RuntimeError("A final wavelength was not provided on the "\
                               +"command-line nor in the data file. "\
                               +"Please provide one.")
    else:
        d_som6.attr_list["Wavelength_final"] = config.wavelength_final

    # Note: time_zero_slope MUST be a tuple
    if config.time_zero_slope is None:
        try:
            config.time_zero_slope = d_som6.attr_list["Time_zero_slope"]
        except KeyError:
            config.time_zero_slope = (float(0.0), float(0.0))
            d_som6.attr_list["Time_zero_slope"] = config.time_zero_slope
    else:
        d_som6.attr_list["Time_zero_slope"] = config.time_zero_slope

    # Note: time_zero_offset MUST be a tuple
    if config.time_zero_offset is None:
        try:
            config.time_zero_offset = d_som6.attr_list["Time_zero_offset"]
        except KeyError:
            config.time_zero_offset = (float(0.0), float(0.0))
            d_som6.attr_list["Time_zero_offset"] = config.time_zero_offset
    else:
        d_som6.attr_list["Time_zero_offset"] = config.time_zero_offset

    if config.verbose:
        print "Converting TOF to wavelength"

    if tim is not None:
        tim.getTime(False)

    (d_som7, m_som2) = convert_data_and_mon_to_wavelength(config, d_som6,
                                                          m_som1)

    if tim is not None:
        tim.getTime(msg="After converting TOF to wavelength: ")

    if config.dump_wave:
        hlr_utils.write_file(config.data, "text/Spec", d_som7,
                             output_ext="pxl",
                             verbose=config.verbose,
                             message="pixel wavelength information")
        
    del d_som6, m_som1

    if config.mon_eff is None:
        m_eff2 = None
    else:
        try:
            config.mon_eff.title()
            if config.verbose:
                print "Reading monitor efficiency file"
                
            mon_eff_dst = DST.getInstance("text/xml", config.mon_eff)
            m_eff1 = mon_eff_dst.getSOM("/entry/monitor2")
            mon_eff_dst.release_resource()
            if config.verbose:
                print "Rebinning monitor efficiency"

            m_eff2 = rebin_mon_eff(m_som2, m_eff1)
                
            del m_eff1
                    
        except AttributeError:
            m_eff2 = config.mon_eff

    if config.verbose and m_eff2 is not None:
        print "Correcting monitor data for efficiency"
        
    m_som3 = eff_correct_mon(m_som2, m_eff2)

    del m_som2

    if config.det_eff is None:
        det_eff2 = None
    else:
        try:
            config.det_eff.title()
            if config.verbose:
                print "Reading detector efficiency file"
                
            det_eff_dst = DST.getInstance("text/xml", config.det_eff)
            det_eff1 = det_eff_dst.getSOM("/entry/dectector")
            det_eff_dst.release_resource()
            if config.verbose:
                print "Rebinning detector efficiency"

            det_eff2 = rebin_det_eff(d_som7, det_eff1)

            del det_eff1

        except AttributeError:
            det_eff2 = config.det_eff

    if config.verbose and det_eff2 is not None:
        print "Correcting data for detector efficiency"

    d_som8 = eff_correct_data(d_som7, det_eff2)

    del d_som7, det_eff2

    if config.verbose and m_som3 is not None:
        print "Normalizing data by monitor"
        
    d_som9 = norm_data_by_mon(config, d_som8, m_som3)

    del d_som8

    # Note: initial_energy_offset MUST be a tuple
    if config.initial_energy_offset is None:
        try:
            config.initial_energy_offset = \
                                       d_som9.attr_list\
                                       ["Initial_energy_offset"]
        except KeyError:
            config.initial_energy_offset = None
            d_som9.attr_list["Initial_energy_offset"] = \
                                                    config.\
                                                    initial_energy_offset
    else:
        d_som9.attr_list["Initial_energy_offset"] = \
                                                  config.initial_energy_offset

    if config.verbose:
        print "Converting initial wavelength to k_initial"

    if tim is not None:
        tim.getTime(False)

    d_som10 = calc_k_initial(config, d_som9)

    if tim is not None:
        tim.getTime(msg="After converting initial wavelength to k_initial: ")
        
    if config.verbose:
        print "Converting initial wavelength to E_initial"

    if tim is not None:
        tim.getTime(False)

    d_som11 = calc_E_initial(config, d_som9)

    if tim is not None:
        tim.getTime(msg="After converting initial wavelength to E_initial: ")

    if config.dump_initial_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som11,
                             output_ext="ixl",
                             verbose=config.verbose,
                             message="pixel initial energy information")

    del d_som9

    # Note: final_energy_offset MUST be a tuple
    if config.final_energy_offset is None:
        try:
            config.final_energy_offset = \
                                       d_som11.attr_list["Final_energy_offset"]
        except KeyError:
            config.final_energy_offset = None
            d_som11.attr_list["Final_energy_offset"] = \
                                                    config.final_energy_offset
    else:
        d_som11.attr_list["Final_energy_offset"] = config.final_energy_offset

    if config.verbose:
        print "Calculating energy transfer"

    if tim is not None:
        tim.getTime(False)

    d_som12 = calc_energy_transfer(config, d_som11)

    if tim is not None:
        tim.getTime(msg="After calculating energy transfer: ")

    del d_som11

    if config.dump_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som12,
                             output_ext="exl",
                             verbose=config.verbose,
                             message="pixel energy transfer information")

    if config.verbose:
        print "Creating 2D spectrum"

    if tim is not None:
        tim.getTime(False)

    d_som13 = create_final(config, d_som12, d_som10)

    if tim is not None:
        tim.getTime(msg="After creation of final spectrum: ")

    del d_som12, d_som10

    # Writing 2D DAVE file

    hlr_utils.write_file(config.output, "text/Dave2d", d_som13,
                         verbose=config.verbose,
                         message="data",
                         replace=False)

    d_som13.attr_list["config"] = config

    hlr_utils.write_file(config.data, "text/rmd", d_som13,
                         output_ext="rmd",
                         verbose=config.verbose,
                         message="metadata",
                         replace=True)
    
    if tim is not None:
        tim.setOldTime(old_time)
        tim.getTime(msg="Total Running Time: ")

if __name__ == "__main__":
    import os
    
    import common_lib
    import dr_lib
    import hlr_utils
    
    # set up the options available
    parser = hlr_utils.SNSOptions("usage: %prog [options] <datafile>")

    # Add BSS specific options
    parser.add_option("", "--dead-time", dest="dead_time",
                      help="Dead time with units (no spaces)")
    
    parser.add_option("", "--tof-start", dest="TOF_start",
                      help="Specify the starting TOF bin for time-independent"\
                      +"background estimation")
    
    parser.add_option("", "--tof-end", dest="TOF_end",
                      help="Specify the ending TOF bin for time-independent"\
                      +"background estimation")
    
    parser.add_option("", "--no-mon-norm", action="store_true",
                      dest="no_mon_norm",
                      help="Flag for turning off monitor normalization")
    
    parser.add_option("", "--mon-start", dest="mon_start",
                      help="Specify the starting bin for monitor integration")
    
    parser.add_option("", "--mon-end", dest="mon_end",
                      help="Specify the ending bin for monitor")
    
    parser.add_option("", "--no-tib", action="store_true", dest="no_tib",
                      help="Flag for turning off time-independent background"\
                      +"subtraction")
    
    parser.add_option("", "--final-wavelength", dest="wavelength_final",
                      help="Specify the final wavelength lambda, err^2 in "\
                      +"Angstroms")
    
    parser.add_option("", "--mon-eff", dest="mon_eff",
                      help="Specify the monitor efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--det-eff", dest="det_eff",
                      help="Specify the detector efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--mon-geom", dest="mon_geom",
                      help="Specify the monitor geometry file")
    
    parser.add_option("", "--det-geom", dest="det_geom",
                      help="Specify the detector geometry file")
    
    parser.add_option("", "--energy-bins", dest="E_bins",
                      help="Specify the minimum and maximum energy values and"\
                      +" the energy bin width in ueV")
    
    parser.add_option("", "--mom-trans-bins", dest="Q_bins",
                      help="Specify the minimum and maximum momentum transfer"\
                      +" values and the momentum transfer bin width in"\
                      +" Angstroms^-1")
    
    parser.add_option("", "--dump-wave", action="store_true", dest="dump_wave",
                      help="Flag to dump the wavelength information for all"\
                      +" pixels")
    parser.set_defaults(dump_wave=False)
    
    parser.add_option("", "--dump-energy", action="store_true",
                      dest="dump_energy",
                      help="Flag to dump the energy transfer information for"\
                      +" all pixels")
    parser.set_defaults(dump_energy=False)
    
    parser.add_option("", "--data-paths", dest="data_paths",
                      help="Specify the comma separated list of detector data"\
                      +"paths and signals. Defaults is "\
                      +"/entry/bank1,1/entry/bank2,1")
    parser.set_defaults(data_paths="/entry/bank1,1,/entry/bank2,1")
    
    parser.add_option("", "--mon-path", dest="mon_path",
                      help="Specify the comma separated list of monitor "\
                      +"path and signal. Default is /entry/monitor,1")
    parser.set_defaults(mon_path="/entry/monitor,1")
    
    parser.add_option("", "--dump-ei", action="store_true",
                      dest="dump_initial_energy",
                      help="Flag to dump the initial energy information for"\
                      +" all pixels")
    parser.set_defaults(dump_ei=False)
    
    parser.add_option("", "--dump-all", action="store_true", dest="dump_all",
                      help="Flag to dump information for all pixels")
    parser.set_defaults(dump_all=False)
    
    parser.add_option("", "--no-filter", action="store_true", dest="no_filter",
                      help="Flag to turn off negative wavelength filtering.")
    parser.set_defaults(no_filter=True)

    parser.add_option("", "--final-energy-offset", dest="final_energy_offset",
                      help="Specify the final energy offset, err^2 in meV")

    parser.add_option("", "--initial-energy-offset",
                      dest="initial_energy_offset",
                      help="Specify the initial energy offset, err^2 in meV")

    parser.add_option("", "--roi-file", dest="roi_file",
                      help="Specify a file that contains a list of pixel ids "\
                      +"to be read from the data")

    parser.add_option("", "--timing", action="store_true", dest="timing",
                      help="Flag to turn on timing of code")
    parser.set_defaults(timing=False)

    parser.add_option("", "--time-zero-offset", dest="time_zero_offset",
                      help="Specify the time zero offset, err^2 in "\
                      +"microseconds")

    parser.add_option("", "--time-zero-slope", dest="time_zero_slope",
                      help="Specify the time zero slope, err^2 in "\
                      +"microseconds")

    parser.add_option("", "--mc", action="store_true", dest="mc",
                      help="Flag to turn on MC reading")
    parser.set_defaults(mc=False)

    parser.add_option("", "--correct", action="store_true", dest="correct",
                      help="Flag to turn on correct calculation of Q")
    parser.set_defaults(correct=False)    

    (options, args) = parser.parse_args()

    # set up the configuration
    configure = hlr_utils.Configure()
    
    # get the datafile name and check it
    if len(args) == 1:
        configure.data = args[0]
        if not hlr_utils.file_exists(configure.data):
            parser.error("Data file [%s] does not exist" % configure.data)
    else:
        if options.data is not None:
            configure.data = hlr_utils.fix_filename(options.data)
            if not hlr_utils.file_exists(configure.data):
                parser.error("Data file [%s] does not exist" % configure.data)
        else:
            parser.error("Did not specify a datafile")
    # create the output file name if there isn't one supplied
    if options.output:
        configure.output = hlr_utils.fix_filename(options.output)
    else:
        outfile = os.path.basename(configure.data)
        path = os.path.join(os.getcwd(), outfile)
        configure.output = hlr_utils.ext_replace(path, "nxs", "txt")
        print "Using %s as output file" % configure.output

    # set the verbosity
    configure.verbose = options.verbose

    configure.norm = hlr_utils.fix_filename(options.norm)
    if configure.norm is not None:
        if not hlr_utils.file_exists(configure.norm):
            parser.error("Normalization file [%s] does not exist" \
                         % configure.norm)
            
    configure.norm_bkg = hlr_utils.fix_filename(options.norm_bkg)
    if configure.norm_bkg is not None:
        if not hlr_utils.file_exists(configure.norm_bkg):
            parser.error("Normalization background file [%s] does not exist"\
                         % configure.norm_bkg)

    configure.data_bkg = hlr_utils.fix_filename(options.data_bkg)
    if configure.data_bkg is not None:
        if not hlr_utils.file_exists(configure.data_bkg):
            parser.error("Background file [%s] does not exist" \
                         % configure.data_bkg)
            
    configure.dark_count = hlr_utils.fix_filename(options.dark_count)
    if configure.dark_count is not None:
        if not hlr_utils.file_exists(configure.dark_count):
            parser.error("Dark-count file [%s] does not exist" \
                         % configure.dark_count)

    if options.mon_eff is not None:
        try:
            configure.mon_eff = hlr_utils.split_values(options.mon_eff)
        except ValueError:
            configure.mon_eff = hlr_utils.fix_filename(options.mon_eff)
            if not hlr_utils.file_exists(configure.mon_eff):
                parser.error("Monitor efficiency file [%s] does not exist" \
                             % configure.mon_eff)
    else:
        configure.mon_eff = options.mon_eff

    if options.det_eff is not None:
        try:
            configure.det_eff = hlr_utils.split_values(options.det_eff)
        except ValueError:
            configure.det_eff = hlr_utils.fix_filename(options.det_eff)
            if not hlr_utils.file_exists(configure.det_eff):
                parser.error("Detector efficiency file [%s] does not exist" \
                             % configure.det_eff)
    else:
        configure.det_eff = options.det_eff
            
    configure.mon_geom = hlr_utils.fix_filename(options.mon_geom)
    if configure.mon_geom is not None:
        if not hlr_utils.file_exists(configure.mon_geom):
            parser.error("Monitor geometry file [%s] does not exist" \
                         % configure.mon_geom)

    configure.det_geom = hlr_utils.fix_filename(options.det_geom)
    if configure.det_geom is not None:
        if not hlr_utils.file_exists(configure.det_geom):
            parser.error("Detector geometry file [%s] does not exist" \
                         % configure.det_geom)

    configure.roi_file = hlr_utils.fix_filename(options.roi_file)
    if configure.roi_file is not None:
        if not hlr_utils.file_exists(configure.roi_file):
            parser.error("Pixel roi file [%s] does not exist" \
                         % configure.roi_file)

    # set the data paths
    configure.data_paths = hlr_utils.create_data_paths(options.data_paths)

    # set the monitor path
    configure.mon_path = hlr_utils.create_data_paths(options.mon_path)

    # set the dead time
    if options.dead_time is not None:
        configure.dead_time = hlr_utils.split_values(options.dead_time)
    else:
        configure.dead_time = options.dead_time
        
    # set the TOF start bin
    configure.TOF_start = options.TOF_start
    # set the TOF end bin
    configure.TOF_end = options.TOF_end
    # set the monitor start bin
    configure.mon_start = options.mon_start
    # set the monitor end bin
    configure.mon_end = options.mon_end
    # set no_mon_norm flag
    configure.no_mon_norm = options.no_mon_norm
    # set no_tib flag
    configure.no_tib = options.no_tib

    # set the final wavelength
    if options.wavelength_final is not None:
        configure.wavelength_final = hlr_utils.split_values(\
            options.wavelength_final)
    else:
        configure.wavelength_final = options.wavelength_final

    # set the final energy offset
    if options.final_energy_offset is not None:
        configure.final_energy_offset = \
                                   hlr_utils.split_values(options.\
                                                          final_energy_offset)
    else:
        configure.final_energy_offset = options.final_energy_offset

    # set the initial energy offset
    if options.initial_energy_offset is not None:
        configure.\
                 initial_energy_offset = \
                 hlr_utils.split_values(options.\
                                        initial_energy_offset)
    else:
        configure.initial_energy_offset = options.initial_energy_offset

    # set the time-zero offset
    if options.time_zero_offset is not None:
        configure.time_zero_offset = hlr_utils.split_values(
            options.time_zero_offset)
    else:
        configure.time_zero_offset = options.time_zero_offset

    # set the time-zero slope
    if options.time_zero_slope is not None:
        configure.time_zero_slope = hlr_utils.split_values(
            options.time_zero_slope)
    else:
        configure.time_zero_slope = options.time_zero_slope

    # set the E bins
    if options.E_bins is not None:
        efacts = options.E_bins.split(',')
        configure.E_bins = hlr_utils.make_axis(float(efacts[0]),
                                               float(efacts[1]),
                                               float(efacts[2]))
    else:
        configure.E_bins = options.E_bins

    # set the Q bins
    if options.Q_bins is not None:
        qfacts = options.Q_bins.split(',')
        configure.Q_bins = hlr_utils.make_axis(float(qfacts[0]),
                                               float(qfacts[1]),
                                               float(qfacts[2]))
    else:
        configure.Q_bins = options.Q_bins

    # set the ability to dump the wavelength information
    configure.dump_wave = options.dump_wave

    # set the ability to dump the energy transfer information
    configure.dump_energy = options.dump_energy
    
    # set the ability to dump the initial energy information
    configure.dump_initial_energy = options.dump_initial_energy

    if options.dump_all:
        configure.dump_wave = True
        configure.dump_energy = True
        configure.dump_initial_energy = True

    # set the no filter option
    configure.no_filter = options.no_filter

    # set MC option
    configure.mc = options.mc

    # set Correct Q calculation flag
    configure.correct = options.correct

    if options.timing:
        import sns_timing
        timer = sns_timing.DiffTime()
    else:
        timer = None
    
    # run the program
    run(configure, timer)
