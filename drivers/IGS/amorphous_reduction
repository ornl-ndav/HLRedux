#!/usr/bin/env python

#                  High-Level Reduction Functions
#           A part of the SNS Analysis Software Suite.
#
#                  Spallation Neutron Source
#          Oak Ridge National Laboratory, Oak Ridge TN.
#
#
#                             NOTICE
#
# For this software and its associated documentation, permission is granted
# to reproduce, prepare derivative works, and distribute copies to the public
# for any purpose and without fee.
#
# This material was prepared as an account of work sponsored by an agency of
# the United States Government.  Neither the United States Government nor the
# United States Department of Energy, nor any of their employees, makes any
# warranty, express or implied, or assumes any legal liability or
# responsibility for the accuracy, completeness, or usefulness of any
# information, apparatus, product, or process disclosed, or represents that
# its use would not infringe privately owned rights.
#

# $Id$

"""
This program covers the functionality outlined in 2.2.1 Powder or
amorphous material reduction in
http://www.sns.gov/asg/projects/SCL/reqspec/DR_Lib_RS.doc
"""

def determine_time_indep_bkg(conf, data_som):
    """Step 3. Determine the sample dependent, time independent
    background B by fitting a line to predetermined end points of
    ItdDXY(TOF) using function 3.43."""

    kwargs = {}

    if conf.TOF_start is not None:
        kwargs["start"] = conf.TOF_start

    if conf.TOF_end is not None:
        kwargs["end"] = conf.TOF_end

    return common_lib.weighted_average(data_som, **kwargs)

def subtract_time_indep_bkg(data_som, B):
    """Step 4. Subtract B from the data spectrum using function 3.2
    with ItdDXY(TOF) as data1 and B as a. The result is ItdsDXY(TOF)."""

    if B is None:
        return data_som

    return dr_lib.subtract_time_indep_bkg(data_som, B)

def convert_data_and_mon_to_wavelength(conf, data_som, mon2_som):
    """Step 5. Convert ItM2(TOF) and ItdsbnDXY(TOF) to ItM2(lambda)
    and ItdsbnDXY(lambda) using function 3.50 for M2 and function 3.48
    for DXY."""

    if mon2_som is not None:
        mon2_som1 = common_lib.tof_to_wavelength_lin_time_zero(
            mon2_som,
            units="microsecond")
    else:
        mon2_som1 = None

    data_som1 = common_lib.tof_to_initial_wavelength_igs_lin_time_zero(
        data_som,
        units="microsecond",
        run_filter=conf.filter)
        
    return (data_som1, mon2_som1)

def calc_k_initial(config, data_som):
    """Step 14. Calculate incident wavevector using function 3.24."""

    return common_lib.wavelength_to_scalar_k(data_som)

def calc_E_initial(config, data_som):
    """Step 15. Calculate incident energy using function 3.22."""

    return common_lib.wavelength_to_energy(data_som)

def calc_energy_transfer(conf, data_som):
    """Combines Steps 17 and 18 to calculate energy transfer using function
    3.30."""

    return dr_lib.igs_energy_transfer(data_som)

def create_final(conf, data_som):
    """Combines Steps 16,19,20 and 21 to create final 2D spectrum"""

    return dr_lib.create_2D_dist(data_som, conf.E_bins, conf.Q_bins,
                                 so_id="Full Detector",
                                 y_label="counts",
                                 y_units="counts / (ueV * A^-1)",
                                 x_labels=["Q transfer","energy transfer"],
                                 x_units=["1/Angstroms","ueV"])

def create_final_new(conf, E_t_som, k_i_som):
    """Combines Steps 16,19,20 and 21 to create final 2D spectrum"""

    return dr_lib.create_E_vs_Q_igs(E_t_som, k_i_som,
                                    conf.E_bins, conf.Q_bins,
                                    so_id="Full Detector",
                                    y_label="counts",
                                    y_units="counts / (ueV * A^-1)",
                                    x_labels=["Q transfer",
                                              "energy transfer"],
                                    x_units=["1/Angstroms","ueV"])

def process_data(datalist, conf, t, i_geom_dst, **kwargs):
    """
    This function combines Steps 1 through 8 of the data reduction process as
    specified by the document. 
    """
    import DST

    try:
        dataset_type = kwargs["dataset_type"]
    except KeyError:
        dataset_type = "data"
    
    # Step 1: Open appropriate data files
    try:
        data_dst = DST.getInstance("application/x-NeXus", datalist)
    except SystemError:
        print "ERROR: Failed to read file %s" % datalist
        sys.exit(-1)

    if not conf.mc:
        so_axis = "time_of_flight"
    else:
        so_axis = "Time_of_Flight__us_"

    if conf.verbose:
        print "Reading %s file" % dataset_type

    dp_som1 = data_dst.getSOM(conf.data_paths, so_axis,
                              roi_file=conf.roi_file)

    if t is not None:
        t.getTime(msg="After reading %s " % dataset_type)

    if conf.inst_geom is not None:
        i_geom_dst.setGeometry(conf.data_paths, dp_som1)

    if conf.no_mon_norm:
        dm_som1 = None
    else:
        if conf.verbose:
            print "Reading in monitor data from %s file" % dataset_type
        som_id = conf.mon_path
        dm_som1 = data_dst.getSOM(som_id, so_axis)
        
        if t is not None:
            t.getTime(msg="After reading monitor data ")

        if conf.inst_geom is not None:
            i_geom_dst.setGeometry(conf.mon_path, dm_som1)

    data_dst.release_resource()

    # Step 2: Dead Time Correction
    # No dead time correction is being applied to the data yet

    # Step 3: Time-independent background determination
    if not conf.no_tib:
        if conf.verbose:
            print "Determining time-independent background from data"
            
        B = determine_time_indep_bkg(conf, dp_som1)
        if t is not None:
            t.getTime(msg="After determining time-independent background ")
    else:
        B = None

    # Step 4: Subtract time-independent background
    if conf.verbose and B is not None:
        print "Subtracting time-independent background from data"
        
    dp_som2 = subtract_time_indep_bkg(dp_som1, B)

    if B is not None:
        if t is not None:
            t.getTime(msg="After subtracting time-independent background ")

    del dp_som1, B

    # Provide override capability for final wavelength, time-zero slope and
    # time-zero offset

    if conf.wavelength_final is not None:
        dp_som1.attr_list["Wavelength_final"] = conf.wavelength_final

    # Note: time_zero_slope MUST be a tuple
    if conf.time_zero_slope is not None:
        dp_som1.attr_list["Time_zero_slope"] = conf.time_zero_slope

    # Note: time_zero_offset MUST be a tuple
    if conf.time_zero_offset is not None:
        dp_som1.attr_list["Time_zero_offset"] = conf.time_zero_offset


    # Step 5: Convert TOF to wavelength for data and monitor
    if conf.verbose:
        print "Converting TOF to wavelength"

    if t is not None:
        t.getTime(False)

    (dp_som3, dm_som2) = convert_data_and_mon_to_wavelength(conf, dp_som2,
                                                            dm_som1)

    if t is not None:
        t.getTime(msg="After converting TOF to wavelength ")

    if conf.dump_wave:
        hlr_utils.write_file(datalist, "text/Spec", dp_som3,
                             output_ext="pxl",
                             verbose=conf.verbose,
                             message="pixel wavelength information")
    if conf.dump_mon_wave:        
        hlr_utils.write_file(datalist, "text/Spec", dm_som2,
                             output_ext="mxl",
                             verbose=conf.verbose,
                             message="monitor wavelength information")
        
    del dp_som2, dm_som1

    # Step 6: Efficiency correct monitor
    if conf.verbose and dm_som2 is not None:
        print "Efficiency correct monitor data"

    dm_som3 = dr_lib.feff_correct_mon(dm_som2)

    del dm_som2

    # Step 7: Rebin monitor axis onto detector pixel axis
    if conf.verbose and dm_som3 is not None:
        print "Rebin monitor axis to detector pixel axis"

    dm_som4 = dr_lib.rebin_efficiency(dm_som3, dp_som3)

    del dm_som3

    # Step 8: Normalize data by monitor
    if conf.verbose and dm_som4 is not None:
        print "Normalizing data by monitor"

    if dm_som4 is not None:
        dp_som4 = common_lib.div_ncerr(dp_som3, dm_som4)
    else:
        dp_som4 = dp_som3

    del dm_som4, dp_som3

    return dp_som4

def run(config, tim=None):
    import sys 
    import DST

    if tim is not None:
        tim.getTime(False)
        old_time = tim.getOldTime()

    if config.data is None:
        raise RuntimeError("Need to pass a data filename to the driver "\
                           +"script.")

    # Read in geometry if one is provided
    if config.inst_geom is not None:
        if config.verbose:
            print "Reading in instrument geometry file"
            
        inst_geom_dst = DST.getInstance("application/x-NxsGeom",
                                        config.inst_geom)
    else:
        inst_geom_dst = None

    # Perform Steps 1-8 on sample data
    d_som1 = process_data(config.data, config, tim, inst_geom_dst)

    # Perform Steps 1-8 on empty can data
    if config.ecan is not None:
        e_som1 = process_data(config.ecan, config, tim, inst_geom_dst,
                             dataset_type="empty can")
    else:
        e_som1 = None

    # Perform Steps 1-8 on normalization data            
    if config.norm is not None:
        n_som1 = process_data(config.norm, config, tim, inst_geom_dst,
                             dataset_type="normalization")
    else:
        n_som1 = None

    # Perform Steps 1-8 on background data
    if config.back is not None:
        b_som1 = process_data(config.back, config, tim, inst_geom_dst,
                             dataset_type="background")
    else:
        b_som1 = None

    inst_geom_dst.release_resource()
        
    # Step 9: Subtract background spectrum from sample spectrum    
    d_som2 = dr_lib.subtract_bkg_from_data(d_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="data")

    # Step 10: Subtract background spectrum from empty can spectrum    
    e_som2 = dr_lib.subtract_bkg_from_data(e_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="empty can")

    # Step 11: Subtract background spectrum from normalization spectrum
    n_som2 = dr_lib.subtract_bkg_from_data(n_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="normalization")
    del b_som1

    # Step 12: Subtract empty can spectrum from sample spectrum    
    d_som3 = dr_lib.subtract_bkg_from_data(d_som2, e_som2,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="empty can",
                                           dataset2="data")

    del d_som2
    
    # Step 13: Subtract empty can spectrum from normalization spectrum
    n_som3 = dr_lib.subtract_bkg_from_data(n_som2, e_som2,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="empty can",
                                           dataset2="normalization")    

    del n_som2, e_som2

    # Step 14: Integrate normalization spectra
    if config.verbose and n_som3 is not None:
        print "Integrating normalization spectra"

    norm_int = dr_lib.integrate_spectra(n_som3, start=config.norm_start,
                                        end=config.norm_end)

    del n_som3
        
    if config.verbose and norm_int is not None:
        print "Normalizing data by normalization data"

    if norm_int is not None:
        d_som4 = common_lib.div_ncerr(d_som3, norm_int)
    else:
        d_som4 = d_som3

    if norm_int is not None:
        if tim is not None:
            tim.getTime(msg="After normalizing data ")

    del d_som3, norm_int

    #if config.verbose:
    #    print "Converting initial wavelength to k_initial"

    #if tim is not None:
    #    tim.getTime(False)

    #d_som5 = calc_k_initial(config, d_som4)

    #if tim is not None:
    #    tim.getTime(msg="After converting initial wavelength to k_initial ")
        
    if config.verbose:
        print "Converting initial wavelength to E_initial"

    if tim is not None:
        tim.getTime(False)

    d_som6 = calc_E_initial(config, d_som4)

    if tim is not None:
        tim.getTime(msg="After converting initial wavelength to E_initial ")

    if config.dump_initial_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som6,
                             output_ext="ixl",
                             verbose=config.verbose,
                             message="pixel initial energy information")

    del d_som4

    if config.verbose:
        print "Calculating energy transfer"

    if tim is not None:
        tim.getTime(False)

    d_som7 = calc_energy_transfer(config, d_som6)

    if tim is not None:
        tim.getTime(msg="After calculating energy transfer ")

    del d_som6

    if config.dump_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som7,
                             output_ext="exl",
                             verbose=config.verbose,
                             message="pixel energy transfer information")

    if config.verbose:
        print "Creating 2D spectrum"

    if tim is not None:
        tim.getTime(False)

    if config.correct:
        #d_som8 = create_final_new(config, d_som7, d_som5)
        pass
    else:
        d_som8 = create_final(config, d_som7)

    if tim is not None:
        tim.getTime(msg="After creation of final spectrum ")

    del d_som7
    #if config.correct:
    #    del d_som5

    # Writing 2D DAVE file

    hlr_utils.write_file(config.output, "text/Dave2d", d_som8,
                         verbose=config.verbose,
                         message="data",
                         replace_ext=False)

    d_som8.attr_list["config"] = config

    hlr_utils.write_file(config.data, "text/rmd", d_som8,
                         output_ext="rmd",
                         verbose=config.verbose,
                         message="metadata")
    
    if tim is not None:
        tim.setOldTime(old_time)
        tim.getTime(msg="Total Running Time: ")

if __name__ == "__main__":
    import os
    
    import common_lib
    import dr_lib
    import hlr_utils
    
    # set up the options available
    parser = hlr_utils.SNSOptions("usage: %prog [options] <datafile>",
                                  inst="IGS")

    # Set defaults for imported options
    parser.set_defaults(data_paths="/entry/bank1,1,/entry/bank2,1")
    
    # Add BSS specific options
    parser.add_option("", "--dead-time", dest="dead_time",
                      help="Dead time with units (no spaces)")
    
    parser.add_option("", "--tof-start", dest="TOF_start",
                      help="Specify the starting TOF bin for time-independent"\
                      +"background estimation")
    
    parser.add_option("", "--tof-end", dest="TOF_end",
                      help="Specify the ending TOF bin for time-independent"\
                      +"background estimation")
    
    parser.add_option("", "--no-mon-norm", action="store_true",
                      dest="no_mon_norm",
                      help="Flag for turning off monitor normalization")
    
    parser.add_option("", "--norm-start", dest="norm_start",
                      help="Specify the starting wavelength for "\
                      +"normalization integration")
    
    parser.add_option("", "--norm-end", dest="norm_end",
                      help="Specify the ending wavelength for "\
                      +"normalization integration")
    
    parser.add_option("", "--no-tib", action="store_true", dest="no_tib",
                      help="Flag for turning off time-independent background"\
                      +"subtraction")
    
    parser.add_option("", "--final-wavelength", dest="wavelength_final",
                      help="Specify the final wavelength lambda, err^2 in "\
                      +"Angstroms")
    
    parser.add_option("", "--mon-eff", dest="mon_eff", metavar="TUPLE",
                      help="Specify the monitor efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--det-eff", dest="det_eff",
                      help="Specify the detector efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--energy-bins", dest="E_bins",
                      help="Specify the minimum and maximum energy values and"\
                      +" the energy bin width in ueV")
    
    parser.add_option("", "--mom-trans-bins", dest="Q_bins",
                      help="Specify the minimum and maximum momentum transfer"\
                      +" values and the momentum transfer bin width in"\
                      +" Angstroms^-1")
    
    parser.add_option("", "--dump-wave", action="store_true", dest="dump_wave",
                      help="Flag to dump the wavelength information for all"\
                      +" pixels")
    parser.set_defaults(dump_wave=False)

    parser.add_option("", "--dump-mon-wave", action="store_true",
                      dest="dump_mon_wave",
                      help="Flag to dump the wavelength information for the"\
                      +" monitor")
    parser.set_defaults(dump_mon_wave=False)    
    
    parser.add_option("", "--dump-energy", action="store_true",
                      dest="dump_energy",
                      help="Flag to dump the energy transfer information for"\
                      +" all pixels")
    parser.set_defaults(dump_energy=False)
    
    parser.add_option("", "--mon-path", dest="mon_path",
                      help="Specify the comma separated list of monitor "\
                      +"path and signal. Default is /entry/monitor,1")
    parser.set_defaults(mon_path="/entry/monitor,1")
    
    parser.add_option("", "--dump-ei", action="store_true",
                      dest="dump_initial_energy",
                      help="Flag to dump the initial energy information for"\
                      +" all pixels")
    parser.set_defaults(dump_ei=False)
    
    parser.add_option("", "--dump-all", action="store_true", dest="dump_all",
                      help="Flag to dump information for all pixels")
    parser.set_defaults(dump_all=False)
    
    parser.add_option("", "--no-filter", action="store_false", dest="filter",
                      help="Flag to turn off negative wavelength filtering.")

    parser.add_option("", "--filter", action="store_true", dest="filter",
                      help="Flag to turn on negative wavelength filtering. "\
                      +"This is the default operation.")   
    parser.set_defaults(filter=True)

    parser.add_option("", "--roi-file", dest="roi_file",
                      help="Specify a file that contains a list of pixel ids "\
                      +"to be read from the data")

    parser.add_option("", "--timing", action="store_true", dest="timing",
                      help="Flag to turn on timing of code")
    parser.set_defaults(timing=False)

    parser.add_option("", "--time-zero-offset", dest="time_zero_offset",
                      help="Specify the time zero offset, err^2 in "\
                      +"microseconds")

    parser.add_option("", "--time-zero-slope", dest="time_zero_slope",
                      help="Specify the time zero slope, err^2 in "\
                      +"microseconds")

    parser.add_option("", "--mc", action="store_true", dest="mc",
                      help="Flag to turn on MC reading")
    parser.set_defaults(mc=False)

    parser.add_option("", "--correct", action="store_true", dest="correct",
                      help="Flag to turn on correct calculation of Q")
    parser.set_defaults(correct=False)    

    (options, args) = parser.parse_args()

    # set up the configuration
    configure = hlr_utils.Configure()
    
    # get the datafile name and check it
    if len(args) == 1:
        configure.data = args[0]
        if not hlr_utils.file_exists(configure.data):
            parser.error("Data file [%s] does not exist" % configure.data)
    else:
        if options.data is not None:
            configure.data = hlr_utils.fix_filename(options.data)
            if not hlr_utils.file_exists(configure.data):
                parser.error("Data file [%s] does not exist" % configure.data)
        else:
            parser.error("Did not specify a datafile")
    # create the output file name if there isn't one supplied
    if options.output:
        configure.output = hlr_utils.fix_filename(options.output)
    else:
        outfile = os.path.basename(configure.data)
        path = os.path.join(os.getcwd(), outfile)
        configure.output = hlr_utils.ext_replace(path, "nxs", "txt")
        print "Using %s as output file" % configure.output

    # set the verbosity
    configure.verbose = options.verbose

    configure.norm = hlr_utils.fix_filename(options.norm)
    if configure.norm is not None:
        if not hlr_utils.file_exists(configure.norm):
            parser.error("Normalization file [%s] does not exist" \
                         % configure.norm)

    configure.ecan = hlr_utils.fix_filename(options.ecan)
    if configure.ecan is not None:
        if not hlr_utils.file_exists(configure.ecan):
            parser.error("Empty can file [%s] does not exist" \
                         % configure.ecan)            
            
    configure.back = hlr_utils.fix_filename(options.back)
    if configure.back is not None:
        if not hlr_utils.file_exists(configure.back):
            parser.error("Background file [%s] does not exist" \
                         % configure.back)
            
    if options.mon_eff is not None:
        try:
            configure.mon_eff = hlr_utils.split_values(options.mon_eff)
        except ValueError:
            configure.mon_eff = hlr_utils.fix_filename(options.mon_eff)
            if not hlr_utils.file_exists(configure.mon_eff):
                parser.error("Monitor efficiency file [%s] does not exist" \
                             % configure.mon_eff)
    else:
        configure.mon_eff = options.mon_eff

    if options.det_eff is not None:
        try:
            configure.det_eff = hlr_utils.split_values(options.det_eff)
        except ValueError:
            configure.det_eff = hlr_utils.fix_filename(options.det_eff)
            if not hlr_utils.file_exists(configure.det_eff):
                parser.error("Detector efficiency file [%s] does not exist" \
                             % configure.det_eff)
    else:
        configure.det_eff = options.det_eff
            
    configure.inst_geom = hlr_utils.fix_filename(options.inst_geom)
    if configure.inst_geom is not None:
        if not hlr_utils.file_exists(configure.inst_geom):
            parser.error("Instrument geometry file [%s] does not exist" \
                         % configure.inst_geom)

    configure.roi_file = hlr_utils.fix_filename(options.roi_file)
    if configure.roi_file is not None:
        if not hlr_utils.file_exists(configure.roi_file):
            parser.error("Pixel roi file [%s] does not exist" \
                         % configure.roi_file)

    # set the data paths
    configure.data_paths = hlr_utils.create_data_paths(options.data_paths)

    # set the monitor path
    configure.mon_path = hlr_utils.create_data_paths(options.mon_path)

    # set the dead time
    if options.dead_time is not None:
        configure.dead_time = hlr_utils.split_values(options.dead_time)
    else:
        configure.dead_time = options.dead_time
        
    # set the TOF start bin
    configure.TOF_start = options.TOF_start
    # set the TOF end bin
    configure.TOF_end = options.TOF_end
    # set the normalization start wavelength
    configure.norm_start = options.norm_start
    # set the normalization end wavelength
    configure.norm_end = options.norm_end
    # set no_mon_norm flag
    configure.no_mon_norm = options.no_mon_norm
    # set no_tib flag
    configure.no_tib = options.no_tib

    # set the final wavelength
    if options.wavelength_final is not None:
        configure.wavelength_final = hlr_utils.split_values(\
            options.wavelength_final)
    else:
        configure.wavelength_final = options.wavelength_final

    # set the time-zero offset
    if options.time_zero_offset is not None:
        configure.time_zero_offset = hlr_utils.split_values(
            options.time_zero_offset)
    else:
        configure.time_zero_offset = options.time_zero_offset

    # set the time-zero slope
    if options.time_zero_slope is not None:
        configure.time_zero_slope = hlr_utils.split_values(
            options.time_zero_slope)
    else:
        configure.time_zero_slope = options.time_zero_slope

    # set the E bins
    if options.E_bins is not None:
        efacts = options.E_bins.split(',')
        configure.E_bins = hlr_utils.make_axis(float(efacts[0]),
                                               float(efacts[1]),
                                               float(efacts[2]))
    else:
        configure.E_bins = options.E_bins

    # set the Q bins
    if options.Q_bins is not None:
        qfacts = options.Q_bins.split(',')
        configure.Q_bins = hlr_utils.make_axis(float(qfacts[0]),
                                               float(qfacts[1]),
                                               float(qfacts[2]))
    else:
        configure.Q_bins = options.Q_bins

    # set the ability to dump the wavelength information
    configure.dump_wave = options.dump_wave

    # set the ability to dump the monitor wavelength information
    configure.dump_mon_wave = options.dump_mon_wave    

    # set the ability to dump the energy transfer information
    configure.dump_energy = options.dump_energy
    
    # set the ability to dump the initial energy information
    configure.dump_initial_energy = options.dump_initial_energy

    if options.dump_all:
        configure.dump_wave = True
        configure.dump_mon_wave = True
        configure.dump_energy = True
        configure.dump_initial_energy = True

    # set the filter option
    configure.filter = options.filter

    # set MC option
    configure.mc = options.mc

    # set Correct Q calculation flag
    configure.correct = options.correct

    if options.timing:
        import sns_timing
        timer = sns_timing.DiffTime()
    else:
        timer = None
    
    # run the program
    run(configure, timer)
