#!/usr/bin/env python

#                  High-Level Reduction Functions
#           A part of the SNS Analysis Software Suite.
#
#                  Spallation Neutron Source
#          Oak Ridge National Laboratory, Oak Ridge TN.
#
#
#                             NOTICE
#
# For this software and its associated documentation, permission is granted
# to reproduce, prepare derivative works, and distribute copies to the public
# for any purpose and without fee.
#
# This material was prepared as an account of work sponsored by an agency of
# the United States Government.  Neither the United States Government nor the
# United States Department of Energy, nor any of their employees, makes any
# warranty, express or implied, or assumes any legal liability or
# responsibility for the accuracy, completeness, or usefulness of any
# information, apparatus, product, or process disclosed, or represents that
# its use would not infringe privately owned rights.
#

# $Id$

"""
This program covers the functionality outlined in 2.2.1 Powder or
amorphous material reduction in
http://www.sns.gov/asg/projects/SCL/reqspec/DR_Lib_RS.doc
"""

def run(config, tim=None):
    import sys 
    import DST

    if tim is not None:
        tim.getTime(False)
        old_time = tim.getOldTime()

    if config.data is None:
        raise RuntimeError("Need to pass a data filename to the driver "\
                           +"script.")

    # Read in geometry if one is provided
    if config.inst_geom is not None:
        if config.verbose:
            print "Reading in instrument geometry file"
            
        inst_geom_dst = DST.getInstance("application/x-NxsGeom",
                                        config.inst_geom)
    else:
        inst_geom_dst = None

    # Perform Steps 1-8 on sample data
    d_som1 = dr_lib.process_igs_data(config.data, config, timer=tim,
                                     inst_geom_dst=inst_geom_dst)

    # Perform Steps 1-8 on empty can data
    if config.ecan is not None:
        e_som1 = dr_lib.process_igs_data(config.ecan, config, timer=tim,
                                         inst_geom_dst=inst_geom_dst,
                                         dataset_type="empty can")
    else:
        e_som1 = None

    # Perform Steps 1-8 on normalization data            
    if config.norm is not None:
        n_som1 = dr_lib.process_igs_data(config.norm, config, timer=tim,
                                         inst_geom_dst=inst_geom_dst,
                                         dataset_type="normalization")
    else:
        n_som1 = None

    # Perform Steps 1-8 on background data
    if config.back is not None:
        b_som1 = dr_lib.process_igs_data(config.back, config, timer=tim,
                                         inst_geom_dst=inst_geom_dst,
                                         dataset_type="background")
    else:
        b_som1 = None

    if inst_geom_dst is not None:
        inst_geom_dst.release_resource()
        
    # Step 9: Subtract background spectrum from sample spectrum    
    d_som2 = dr_lib.subtract_bkg_from_data(d_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="data")

    # Step 10: Subtract background spectrum from empty can spectrum    
    e_som2 = dr_lib.subtract_bkg_from_data(e_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="empty can")

    # Step 11: Subtract background spectrum from normalization spectrum
    n_som2 = dr_lib.subtract_bkg_from_data(n_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="background",
                                           dataset2="normalization")
    del b_som1

    # Step 12: Subtract empty can spectrum from sample spectrum    
    d_som3 = dr_lib.subtract_bkg_from_data(d_som2, e_som2,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="empty can",
                                           dataset2="data")

    del d_som2
    
    # Step 13: Subtract empty can spectrum from normalization spectrum
    n_som3 = dr_lib.subtract_bkg_from_data(n_som2, e_som2,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="empty can",
                                           dataset2="normalization")    

    del n_som2, e_som2

    # Step 14: Integrate normalization spectra
    if config.verbose and n_som3 is not None:
        print "Integrating normalization spectra"

    norm_int = dr_lib.integrate_spectra(n_som3, start=config.norm_start,
                                        end=config.norm_end)

    del n_som3
        
    if config.verbose and norm_int is not None:
        print "Normalizing data by normalization data"

    if norm_int is not None:
        d_som4 = common_lib.div_ncerr(d_som3, norm_int)
    else:
        d_som4 = d_som3

    if norm_int is not None:
        if tim is not None:
            tim.getTime(msg="After normalizing data ")

    del d_som3, norm_int

    # Step 15: Convert initial wavelength to k_initial
    if config.verbose and config.correct:
        print "Converting initial wavelength to k_initial"

    if tim is not None and config.correct:
        tim.getTime(False)

    if config.correct:
        d_som5 = common_lib.wavelength_to_scalar_k(d_som4)
    else:
        d_som5 = None

    if tim is not None and config.correct:
        tim.getTime(msg="After converting initial wavelength to k_initial ")

    # Step 16: Convert initial wavelength to E_initial
    if config.verbose:
        print "Converting initial wavelength to E_initial"

    if tim is not None:
        tim.getTime(False)

    d_som6 = common_lib.wavelength_to_energy(d_som4)

    if tim is not None:
        tim.getTime(msg="After converting initial wavelength to E_initial ")

    if config.dump_initial_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som6,
                             output_ext="ixl",
                             verbose=config.verbose,
                             message="pixel initial energy information")

    del d_som4

    # Step 17: Calculate energy transfer
    if config.verbose:
        print "Calculating energy transfer"

    if tim is not None:
        tim.getTime(False)

    d_som7 = dr_lib.igs_energy_transfer(d_som6)

    if tim is not None:
        tim.getTime(msg="After calculating energy transfer ")

    del d_som6

    if config.dump_energy:
        hlr_utils.write_file(config.data, "text/Spec", d_som7,
                             output_ext="exl",
                             verbose=config.verbose,
                             message="pixel energy transfer information")

    # Write 3-columna ASCII file for E_t
    d_som7_1 = dr_lib.sum_all_spectra(d_som7, rebin_axis=config.E_bins)
    hlr_utils.write_file(config.data, "text/Spec", d_som7_1,
                         output_ext="etr",
                         verbose=config.verbose,
                         message="combined energy transfer information") 
    
    del d_som7_1

    # Steps 18 to end: Calculate Q and create S(Q, E_t)
    if config.verbose:
        print "Creating 2D spectrum"

    if tim is not None:
        tim.getTime(False)

    if config.correct:
        d_som8 = dr_lib.create_E_vs_Q_igs(d_som7, d_som5,
                                          config.E_bins, config.Q_bins,
                                          so_id="Full Detector",
                                          y_label="counts",
                                          y_units="counts / (ueV * A^-1)",
                                          x_labels=["Q transfer",
                                                    "energy transfer"],
                                          x_units=["1/Angstroms","ueV"])
    else:
        d_som8 = dr_lib.create_2D_dist(d_som7, config.E_bins, config.Q_bins,
                                       so_id="Full Detector",
                                       y_label="counts",
                                       y_units="counts / (ueV * A^-1)",
                                       x_labels=["Q transfer",
                                                 "energy transfer"],
                                       x_units=["1/Angstroms","ueV"])

    if tim is not None:
        tim.getTime(msg="After creation of final spectrum ")

    del d_som7
    if config.correct:
        del d_som5

    # Writing 2D DAVE file

    hlr_utils.write_file(config.output, "text/Dave2d", d_som8,
                         verbose=config.verbose,
                         message="data",
                         replace_ext=False)

    d_som8.attr_list["config"] = config

    hlr_utils.write_file(config.data, "text/rmd", d_som8,
                         output_ext="rmd",
                         verbose=config.verbose,
                         message="metadata")
    
    if tim is not None:
        tim.setOldTime(old_time)
        tim.getTime(msg="Total Running Time: ")

if __name__ == "__main__":
    import os
    
    import common_lib
    import dr_lib
    import hlr_utils
    
    # set up the options available
    parser = hlr_utils.IgsOptions("usage: %prog [options] <datafile>")

    # Set defaults for imported options
    parser.set_defaults(data_paths="/entry/bank1,1,/entry/bank2,1")
    parser.set_defaults(mon_path="/entry/monitor,1")
    parser.set_defaults(norm_start="6.24")
    parser.set_defaults(norm_end="6.30")
    
    # Add BSS specific options
    parser.add_option("", "--mon-eff", dest="mon_eff", metavar="TUPLE",
                      help="Specify the monitor efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--det-eff", dest="det_eff",
                      help="Specify the detector efficiency file or an "\
                      +"efficiency tuple (efficiency,error2)")
    
    parser.add_option("", "--energy-bins", dest="E_bins",
                      help="Specify the minimum and maximum energy values and"\
                      +" the energy bin width in ueV")
    
    parser.add_option("", "--mom-trans-bins", dest="Q_bins",
                      help="Specify the minimum and maximum momentum transfer"\
                      +" values and the momentum transfer bin width in"\
                      +" Angstroms^-1")
    
    parser.add_option("", "--dump-energy", action="store_true",
                      dest="dump_energy",
                      help="Flag to dump the energy transfer information for"\
                      +" all pixels")
    parser.set_defaults(dump_energy=False)
    
    parser.add_option("", "--dump-ei", action="store_true",
                      dest="dump_initial_energy",
                      help="Flag to dump the initial energy information for"\
                      +" all pixels")
    parser.set_defaults(dump_ei=False)
    
    parser.add_option("", "--correct", action="store_true", dest="correct",
                      help="Flag to turn on correct calculation of Q")
    parser.set_defaults(correct=False)    

    (options, args) = parser.parse_args()

    # set up the configuration
    configure = hlr_utils.Configure()
    
    # get the datafile name and check it
    if options.data is not None:
        configure.data = hlr_utils.determine_files(options.data, "BSS",
                                                   stop_on_none=True)
    elif len(args) > 0:
        configure.data = hlr_utils.determine_files(args, "BSS",
                                                   stop_on_none=True)
    else:
        parser.error("Did not specify a datafile")
        
    # create the output file name if there isn't one supplied
    if options.output:
        configure.output = hlr_utils.fix_filename(options.output)
    else:
        outfile = os.path.basename(configure.data[0])
        path = os.path.join(os.getcwd(), outfile)
        configure.output = hlr_utils.ext_replace(path, "nxs", "txt")
        print "Using %s as output file" % configure.output

    # set the verbosity
    configure.verbose = options.verbose

    configure.norm = hlr_utils.determine_files(options.norm, "BSS")

    configure.ecan = hlr_utils.determine_files(options.ecan, "BSS")

    configure.back = hlr_utils.determine_files(options.back, "BSS")
            
    if options.mon_eff is not None:
        try:
            configure.mon_eff = hlr_utils.split_values(options.mon_eff)
        except ValueError:
            configure.mon_eff = hlr_utils.determine_files(options.mon_eff,
                                                          one_file=True)
    else:
        configure.mon_eff = options.mon_eff

    if options.det_eff is not None:
        try:
            configure.det_eff = hlr_utils.split_values(options.det_eff)
        except ValueError:
            configure.det_eff = hlr_utils.determine_files(options.det_eff,
                                                          one_file=True)
    else:
        configure.det_eff = options.det_eff
            
    configure.inst_geom = hlr_utils.determine_files(options.inst_geom,
                                                    one_file=True)

    configure.roi_file = hlr_utils.determine_files(options.roi_file,
                                                   one_file=True)

    # set the data paths
    configure.data_paths = hlr_utils.create_data_paths(options.data_paths)

    # set the monitor path
    configure.mon_path = hlr_utils.create_data_paths(options.mon_path)

    # set the dead time
    if options.dead_time is not None:
        configure.dead_time = hlr_utils.split_values(options.dead_time)
    else:
        configure.dead_time = options.dead_time
        
    # set the time-independent background TOFs
    if options.tib_tofs is not None:
        configure.tib_tofs = options.tib_tofs.split(',')
    else:
        configure.tib_tofs = options.tib_tofs
    # set the normalization start wavelength
    configure.norm_start = options.norm_start
    # set the normalization end wavelength
    configure.norm_end = options.norm_end
    # set no_mon_norm flag
    configure.no_mon_norm = options.no_mon_norm
    # set no_tib flag
    configure.no_tib = options.no_tib

    if not configure.no_tib and configure.tib_tofs is None:
        parser.error("Must provide TOF channels via tib-tofs or set no-tib "
                     +"flag.")

    # set the final wavelength
    if options.wavelength_final is not None:
        configure.wavelength_final = hlr_utils.split_values(\
            options.wavelength_final)
    else:
        configure.wavelength_final = options.wavelength_final

    # set the time-zero offset
    if options.time_zero_offset is not None:
        configure.time_zero_offset = hlr_utils.split_values(
            options.time_zero_offset)
    else:
        configure.time_zero_offset = options.time_zero_offset

    # set the time-zero slope
    if options.time_zero_slope is not None:
        configure.time_zero_slope = hlr_utils.split_values(
            options.time_zero_slope)
    else:
        configure.time_zero_slope = options.time_zero_slope

    # set the E bins
    if options.E_bins is not None:
        efacts = options.E_bins.split(',')
        configure.E_bins = hlr_utils.make_axis(float(efacts[0]),
                                               float(efacts[1]),
                                               float(efacts[2]))
    else:
        configure.E_bins = options.E_bins

    # set the Q bins
    if options.Q_bins is not None:
        qfacts = options.Q_bins.split(',')
        configure.Q_bins = hlr_utils.make_axis(float(qfacts[0]),
                                               float(qfacts[1]),
                                               float(qfacts[2]))
    else:
        configure.Q_bins = options.Q_bins

    # set the ability to dump the time-independent background information
    configure.dump_tib = options.dump_tib

    # set the ability to dump the wavelength information
    configure.dump_wave = options.dump_wave

    # set the ability to dump the monitor wavelength information
    configure.dump_mon_wave = options.dump_mon_wave    

    # set the ability to dump the energy transfer information
    configure.dump_energy = options.dump_energy
    
    # set the ability to dump the initial energy information
    configure.dump_initial_energy = options.dump_initial_energy

    if options.dump_all:
        configure.dump_tib = True
        configure.dump_wave = True
        configure.dump_mon_wave = True
        configure.dump_energy = True
        configure.dump_initial_energy = True

    # set the filter option
    configure.filter = options.filter

    # set MC option
    configure.mc = options.mc

    # set Correct Q calculation flag
    configure.correct = options.correct

    if options.timing:
        import sns_timing
        timer = sns_timing.DiffTime()
    else:
        timer = None
    
    # run the program
    run(configure, timer)
