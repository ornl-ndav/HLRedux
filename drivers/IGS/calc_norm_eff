#!/usr/bin/env python

#                  High-Level Reduction Functions
#           A part of the SNS Analysis Software Suite.
#
#                  Spallation Neutron Source
#          Oak Ridge National Laboratory, Oak Ridge TN.
#
#
#                             NOTICE
#
# For this software and its associated documentation, permission is granted
# to reproduce, prepare derivative works, and distribute copies to the public
# for any purpose and without fee.
#
# This material was prepared as an account of work sponsored by an agency of
# the United States Government.  Neither the United States Government nor the
# United States Department of Energy, nor any of their employees, makes any
# warranty, express or implied, or assumes any legal liability or
# responsibility for the accuracy, completeness, or usefulness of any
# information, apparatus, product, or process disclosed, or represents that
# its use would not infringe privately owned rights.
#

# $Id$

"""
This driver repeats the procedures found in 
http://www.sns.gov/asg/project/SCL/reqspec/DR_Lib_RS.doc to find the 
normalization efficiency on a per-pixel basis from a vanadium run file. It 
will repeat steps 1-8,10,11,13,14.
"""

def run(config, tim):
    import DST

    if tim is not None:
        tim.getTime(False)
        old_time = tim.getOldTime()

    if config.data is None:
        raise RuntimeError("Need to pass a data filename to the driver "\
                           +"script.")

    # Read in geometry if one is provided
    if config.inst_geom is not None:
        if config.verbose:
            print "Reading in instrument geometry file"
            
        inst_geom_dst = DST.getInstance("application/x-NxsGeom",
                                        config.inst_geom)
    else:
        inst_geom_dst = None

    # Perform Steps 1-9 on normalization data            
    n_som1 = dr_lib.process_igs_data(config.data, config, timer=tim,
                                     inst_geom_dst=inst_geom_dst,
                                     dataset_type="normalization",
                                     tib_const=config.tib_norm_const)
    
    # Perform Steps 1-9 on empty can data
    if config.ecan is not None:
        e_som1 = dr_lib.process_igs_data(config.ecan, config, timer=tim,
                                         inst_geom_dst=inst_geom_dst,
                                         dataset_type="empty_can",
                                         tib_const=config.tib_ecan_const)
    else:
        e_som1 = None

    # Perform Steps 1-9 on background data
    if config.back is not None:
        b_som1 = dr_lib.process_igs_data(config.back, config, timer=tim,
                                         inst_geom_dst=inst_geom_dst,
                                         dataset_type="background",
                                         tib_const=config.tib_back_const)
    else:
        b_som1 = None

    if inst_geom_dst is not None:
        inst_geom_dst.release_resource()
        
    # Step 11: Subtract background spectrum from empty can spectrum    
    e_som2 = dr_lib.subtract_bkg_from_data(e_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="empty_can",
                                           dataset2="background")

    # Step 12: Subtract background spectrum from normalization spectrum
    n_som2 = dr_lib.subtract_bkg_from_data(n_som1, b_som1,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="normalization",
                                           dataset2="background")
    del b_som1

    # Step 14: Subtract empty can spectrum from normalization spectrum
    n_som3 = dr_lib.subtract_bkg_from_data(n_som2, e_som2,
                                           verbose=config.verbose,
                                           timer=tim,
                                           dataset1="normalization",
                                           dataset2="empty_can")

    del n_som2, e_som2

    # Step 15: Integrate normalization spectra
    if config.verbose:
        print "Integrating normalization spectra"

    norm_int = dr_lib.integrate_spectra(n_som3, start=config.norm_start,
                                        end=config.norm_end)

    n_som3.attr_list["normalization_int"] = norm_int

    file_comment = "Integration range: %0.3f, %0.3f" % (config.norm_start,
                                                        config.norm_end)

    hlr_utils.write_file(config.data[0], "text/num-info", n_som3,
                         output_ext="norm",
                         verbose=config.verbose,
                         message="normalization values",
                         arguments="normalization_int",
                         comments=[file_comment],
                         tag="Integral", units="counts")

    if tim is not None:
        tim.setOldTime(old_time)
        tim.getTime(msg="Total Running Time: ")

if __name__ == "__main__":
    import dr_lib
    import hlr_utils
    
    # set up the options available
    parser = hlr_utils.IgsOptions("usage: %prog [options] <datafile>", None,
                                  hlr_utils.program_version())

    # Set defaults for imported options
    parser.set_defaults(data_paths="/entry/bank1,1,/entry/bank2,1")
    parser.set_defaults(mon_path="/entry/monitor,1")
    parser.set_defaults(norm_start="6.24")
    parser.set_defaults(norm_end="6.30")

    (options, args) = parser.parse_args()

    # set up the configuration
    configure = hlr_utils.Configure()

    # set the verbosity
    configure.verbose = options.verbose

   # get the datafiles and check them
    if len(args) == 0:
        if options.data is None:
            if options.norm is None:
                parser.error("Provide normalization files as arguments or "\
                             +"via the data or norm CLI flags.")
            else:
                options.data = options.norm
            configure.data = hlr_utils.determine_files(options.data, "BSS",
                                                       stop_on_none=True)
    else:
        configure.data = hlr_utils.determine_files(args, "BSS",
                                                   stop_on_none=True)

    configure.ecan = hlr_utils.determine_files(options.ecan, "BSS")
            
    configure.back = hlr_utils.determine_files(options.back, "BSS")

    configure.inst_geom = hlr_utils.determine_files(options.inst_geom,
                                                    one_file=True)

    configure.roi_file = hlr_utils.determine_files(options.roi_file,
                                                   one_file=True)

    # set the data paths
    configure.data_paths = hlr_utils.create_data_paths(options.data_paths)

    # set the monitor path
    configure.mon_path = hlr_utils.create_data_paths(options.mon_path)

    # set the dead time
    if options.dead_time is not None:
        configure.dead_time = hlr_utils.split_values(options.dead_time)
    else:
        configure.dead_time = options.dead_time

    # set the time-independent background TOFs
    if options.tib_tofs is not None:
        configure.tib_tofs = options.tib_tofs.split(',')
    else:
        configure.tib_tofs = options.tib_tofs

    # set the time-independent background constant for ecan
    if options.tib_ecan_const is not None:
        configure.tib_ecan_const = hlr_utils.split_values(\
            options.tib_ecan_const)
    else:
        configure.tib_ecan_const = options.tib_ecan_const

    # set the time-independent background constant for back
    if options.tib_back_const is not None:
        configure.tib_back_const = hlr_utils.split_values(\
            options.tib_back_const)
    else:
        configure.tib_back_const = options.tib_back_const

    # set the time-independent background constant for norm
    if options.tib_norm_const is not None:
        configure.tib_norm_const = hlr_utils.split_values(\
            options.tib_norm_const)
    else:
        configure.tib_norm_const = options.tib_norm_const        

    # set the normalization start wavelength
    configure.norm_start = float(options.norm_start)

    # set the normalization end wavelength
    configure.norm_end = float(options.norm_end)

    # set no_mon_norm flag
    configure.no_mon_norm = options.no_mon_norm

    # set no_mon_effc flag
    configure.no_mon_effc = options.no_mon_effc

    # set the final wavelength
    if options.wavelength_final is not None:
        configure.wavelength_final = hlr_utils.split_values(\
            options.wavelength_final)
    else:
        configure.wavelength_final = options.wavelength_final

    # set the time-zero offset
    if options.time_zero_offset is not None:
        configure.time_zero_offset = hlr_utils.split_values(
            options.time_zero_offset)
    else:
        configure.time_zero_offset = options.time_zero_offset

    # set the time-zero slope
    if options.time_zero_slope is not None:
        configure.time_zero_slope = hlr_utils.split_values(
            options.time_zero_slope)
    else:
        configure.time_zero_slope = options.time_zero_slope

    # set the ability to dump the time-independent background information
    configure.dump_tib = options.dump_tib

    # set the ability to dump the wavelength information
    configure.dump_wave = options.dump_wave

    # set the ability to dump the monitor wavelength information
    configure.dump_mon_wave = options.dump_mon_wave    

    # set the ability to dump the rebinned monitor wavelength information
    configure.dump_mon_rebin = options.dump_mon_rebin

    # set the ability to dump the efficiency corrected monitor wavelength
    # information
    configure.dump_mon_effc = options.dump_mon_effc        

    # set the ability to dump the wavelength information
    configure.dump_wave_mnorm = options.dump_wave_mnorm

    if options.dump_all:
        configure.dump_tib = True
        configure.dump_wave = True
        configure.dump_mon_wave = True
        configure.dump_mon_wave = True
        configure.dump_mon_effc = True
        configure.dump_mon_rebin = True
        configure.dump_wave_mnorm = True        

    # set the filter option
    configure.filter = options.filter

    # set MC option
    configure.mc = options.mc

    if options.timing:
        import sns_timing
        timer = sns_timing.DiffTime()
    else:
        timer = None
    
    # run the program
    run(configure, timer)
